local open ImplicitTypedTerm in
  fun encodeNat 0w0 = ABS ("f", NONE, ABS ("x", NONE, VAR "x"))
    | encodeNat n = ABS ("f", NONE, ABS ("x", NONE, APP (VAR "f", APP (APP (encodeNat (Word64.- (n, 0w1)), VAR "f"), VAR "x"))))

  fun encodeChar c = encodeNat (Word64.fromInt (ord c))

  fun encodeCharList nil = ABS ("f", NONE, ABS ("x", NONE, VAR "x"))
    | encodeCharList (t :: ts) = ABS ("f", NONE, ABS ("x", NONE, APP (APP (VAR "f", t), APP (APP (encodeCharList ts, VAR "f"), VAR "x"))))

  fun encodeString s = encodeCharList (map encodeChar (String.explode s))
end

val fresh = ref 0

fun gensym () = let
  val i = !fresh
in
  fresh := !fresh + 1
; Int.toString i
end

val tycxt = ref (gensym ())

%%
%eop EOF
%pos unit

%term
  EOF
| QUOTE
| LPAREN
| RPAREN
| ARROW
| DOT
| COLON
| COLONEQ
| LAMBDA
| IN
| LET
| NAT of Word64.word
| CHAR of char
| STRING of string
| ID of string

%nonterm
  program of ImplicitTypedTerm.t
| ty of Type.t
| atty of Type.t
| tyopt of Type.t option
| exp of ImplicitTypedTerm.t
| appexp of ImplicitTypedTerm.t
| atexp of ImplicitTypedTerm.t

%name Parsing
%noshift EOF
%%

program:
  exp
    (exp)

ty:
  atty
    (atty)
| atty ARROW ty
    (Type.ARR (atty, ty))

atty:
  QUOTE ID
    (Type.VAR (ID ^ !tycxt))
| ID
    (Type.CON ID)
| LPAREN ty RPAREN
    (ty)

tyopt:
    (NONE)
| COLON ty
    (tycxt := gensym (); SOME ty)

exp:
  appexp
    (appexp)
| LAMBDA ID tyopt DOT exp
    (ImplicitTypedTerm.ABS (ID, tyopt, exp))
| LET ID tyopt COLONEQ exp IN exp
    (ImplicitTypedTerm.LET (ID, tyopt, exp1, exp2))

appexp:
  atexp (atexp)
| appexp atexp (ImplicitTypedTerm.APP (appexp, atexp))

atexp:
  NAT (encodeNat NAT)
| CHAR (encodeChar CHAR)
| STRING (encodeString STRING)
| ID (ImplicitTypedTerm.VAR ID)
| LPAREN exp RPAREN (exp)
