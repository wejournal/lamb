local open AST.Exp in
  fun encodeNat (r, n) = let
    val i = ref 0w0
    val t = ref (VAR (r, "z"))
  in
    while !i < n do (
      t := APP (r, (VAR (r, "f"), !t))
    ; i := !i + 0w1
    )
  ; ABS (r, ((r, "f"), NONE, ABS (r, ((r, "z"), NONE, !t))))
  end

  fun encodeChar (r, c) = encodeNat (r, LargeWord.fromInt (ord c))

  fun encodeCharList' (r, nil) = VAR (r, "nil")
    | encodeCharList' (r, t :: ts) = APP (r, (APP (r, (VAR (r, "cons"), t)), encodeCharList' (r, ts)))

  fun encodeCharList (r, l) = let
    val nil' = ABS (r, ((r, "f"), NONE, ABS (r, ((r, "z"), NONE, VAR (r, "z")))))
    val cons = ABS (r, ((r, "x"), NONE, ABS (r, ((r, "xs"), NONE, ABS (r, ((r, "f"), NONE, ABS (r, ((r, "z"), NONE, APP (r, (APP (r, (VAR (r, "f"), VAR (r, "x"))), APP (r, (APP (r, (VAR (r, "xs"), VAR (r, "f"))), VAR (r, "z")))))))))))))
  in
    LET (r, ((r, "nil"), NONE, nil', LET (r, ((r, "cons"), NONE, cons, encodeCharList' (r, l)))))
  end

  fun encodeString (r, s) = encodeCharList (r, map (fn c => encodeChar (r, c)) (String.explode s))
end

%%
%eop EOF
%pos cursor

%term
  EOF
| QUOTE
| LPAREN
| RPAREN
| ARROW
| DOT
| COLON
| COLONEQ
| LAMBDA
| DEF
| IN
| LET
| TYPE
| VAL
| NAT of LargeWord.word
| CHAR of char
| STRING of string
| ID of string

%nonterm
  program of AST.Program.t
| decls of AST.Decl.t list
| decl of AST.Decl.t
| ty of AST.Type.t
| atty of AST.Type.t
| asc of AST.Type.t option
| exp of AST.Exp.t
| appexp of AST.Exp.t
| atexp of AST.Exp.t

%name Parsing
%noshift EOF
%%

program:
  decls
    (decls)

decls:
    (nil)
| decl decls
    (decl :: decls)

decl:
  TYPE ID
    (AST.Decl.TYPE ((TYPEleft, IDright), (((IDleft, IDright), ID))))
| VAL ID COLON ty
    (AST.Decl.VAL ((VALleft, tyright), (((IDleft, IDright), ID), ty)))
| DEF ID asc COLONEQ exp
    (AST.Decl.DEF ((DEFleft, expright), (((IDleft, IDright), ID), asc, exp)))

ty:
  atty
    (atty)
| atty ARROW ty
    (AST.Type.ARR ((attyleft, tyright), (atty, ty)))

atty:
  QUOTE ID
    (AST.Type.VAR ((QUOTEleft, IDright), ID))
| ID
    (AST.Type.CON ((IDleft, IDright), ID))
| LPAREN ty RPAREN
    (ty)

asc:
    (NONE)
| COLON ty
    (SOME ty)

exp:
  appexp
    (appexp)
| LAMBDA ID asc DOT exp
    (AST.Exp.ABS ((LAMBDAleft, expright), (((IDleft, IDright), ID), asc, exp)))
| LET ID asc COLONEQ exp IN exp
    (AST.Exp.LET ((LETleft, expright), (((IDleft, IDright), ID), asc, exp1, exp2)))

appexp:
  atexp
    (atexp)
| appexp atexp
    (AST.Exp.APP ((appexpleft, atexpright), (appexp, atexp)))

atexp:
  NAT
    (encodeNat ((NATleft, NATright), NAT))
| CHAR
    (encodeChar ((CHARleft, CHARright), CHAR))
| STRING
    (encodeString ((STRINGleft, STRINGright), STRING))
| ID
    (AST.Exp.VAR ((IDleft, IDright), ID))
| LPAREN exp RPAREN
    (exp)
